I have x years of experience in Java and y years of experience in Spring Boot. I have worked on projects that involve building and deploying microservices, 
creating REST APIs, and integrating with databases. I am also familiar with various Spring Boot modules such as Spring Data, Spring Security, and Spring MVC.

ANNOTATIONS:
@SpringBootApplication: A convenience annotation that combines @Configuration, @EnableAutoConfiguration, and @ComponentScan to enable auto-configuration, component scanning, and configuration for a SB application.
@RestController: Combines @Controller and @ResponseBody to simplify the creation of RESTful web services.making the class a controller where every method returns a domain object instead of a view.
@RequestMapping: Used to map web requests onto specific handler methods or classes in MVC and REST controllers. Supports specifying the HTTP method, path, and other attributes.
@GetMapping: A shortcut for @RequestMapping(method = RequestMethod.GET), specifically mapping HTTP GET requests to handler methods.
@PostMapping: A shortcut for @RequestMapping(method = RequestMethod.POST), specifically mapping HTTP POST requests to handler methods.
@PutMapping: A shortcut for @RequestMapping(method = RequestMethod.PUT), specifically mapping HTTP PUT requests to handler methods.
@DeleteMapping: A shortcut for @RequestMapping(method = RequestMethod.DELETE), specifically mapping HTTP DELETE requests to handler methods.
@PatchMapping: A shortcut for @RequestMapping(method = RequestMethod.PATCH), specifically mapping HTTP PATCH requests to handler methods.
@Component: Marks a Java class as a Spring component. Indicates that a class is a Spring component. It is a generic stereotype annotation for any Spring-managed component
@Service: A specialization of @Component, indicating that a class belongs to the service layer. It is used to annotate service classes
@Repository: A specialization of @Component, indicating that a class belongs to the data access layer. It also enables exception translation for database operations.
@Autowired: Automatically injects dependencies by type. It can be used on constructors, methods, and fields.
@Value: Injects property values from external sources (like properties files) into fields, method parameters, and constructor arguments.
@Configuration: Indicates that a class declares one or more @Bean methods and can be processed by the Spring container to generate bean definitions.
@Bean: Indicates that a method produces a bean to be managed by the Spring container. It is used within @Configuration classes
@EnableAutoConfiguration: Enables Spring Boot’s auto-configuration mechanism, attempting to configure your application automatically based on the dependencies you have added.
@Entity: Specifies that the class is an entity and is mapped to a database table. It is a JPA annotation
@Table: Specifies the table in the database that the entity is mapped to. It is used in conjunction with @Entity
@Id: Specifies the primary key of an entity. It is a JPA annotation
@GeneratedValue: Specifies how the primary key should be generated (e.g., AUTO, IDENTITY, SEQUENCE, TABLE). It is used in conjunction with @Id
@Column: Specifies the details of the column to which a field or property will be mapped. It is used in JPA entities
@EnableScheduling: Enables Spring’s scheduled task execution capability, allowing you to use @Scheduled to schedule tasks.
@Scheduled: Indicates that a method should be scheduled to run at specific intervals. It requires @EnableScheduling to be enabled.
@EnableCaching: Enables Spring’s annotation-driven cache management capability, allowing you to use caching annotations like @Cacheable.
@Cacheable: Indicates that the result of a method call should be cached. If the same method is called with the same parameters, the cached result is returned.
@CacheEvict: Indicates that one or more caches should be cleared when a method is called.
@Transactional: Indicates that a method or class should be executed within a transaction context. It ensures that the method is executed with transaction management.
@RestControllerAdvice: Provides centralized exception handling across all @RestController components. It is a combination of @ControllerAdvice and @ResponseBody.
@ExceptionHandler: Defines a method to handle specific exceptions thrown by request handling methods in controllers or globally in @ControllerAdvice classes
@SpringBootTest: Indicates that the class is a Spring Boot test, loading the complete application context for integration tests. It can be configured to run with different properties and profiles


JPA Annotations: @OneToOne, @OneToMany, @ManyToOne, @ManyToMany
@OneToOne:
  @Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    
    @OneToOne
    private Profile profile;
}

@Entity
public class Profile {
    @Id @GeneratedValue
    private Long id;
    
    @OneToOne(mappedBy = "profile")
    private User user;
}


@OneToMany: and @ManyToOne
@Entity
public class User {
    @Id @GeneratedValue
    private Long id;
    
    @OneToMany(mappedBy = "user")
    private List<Order> orders;
}

@Entity
public class Order {
    @Id @GeneratedValue
    private Long id;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}


@ManyToMany:
@Entity
public class Student {
    @Id @GeneratedValue
    private Long id;
    
    @ManyToMany
    @JoinTable(
        name = "student_course",
        joinColumns = @JoinColumn(name = "student_id"),
        inverseJoinColumns = @JoinColumn(name = "course_id")
    )
    private List<Course> courses;
}

@Entity
public class Course {
    @Id @GeneratedValue
    private Long id;
    
    @ManyToMany(mappedBy = "courses")
    private List<Student> students;
}

@OneToOne: One entity relates to one other entity.
@OneToMany: One entity relates to many other entities.
@ManyToOne: Many entities relate to one other entity.
@ManyToMany: Many entities relate to many other entities

COMPONENTS IN SPRING BOOT:
1.Spring Boot Starter:
Definition: Pre-configured sets of dependencies for building specific types of applications.
Example: spring-boot-starter-web, spring-boot-starter-data-jpa.

2.Spring Boot Auto-Configuration:
Definition: Automatically configures Spring applications based on the dependencies present in the classpath.
Example: Configures a DataSource bean if H2 or another database dependency is found.

3.Spring Boot CLI:
Definition: A command-line tool for running and testing Spring Boot applications.
Example: Allows you to quickly run Groovy scripts.

4.Spring Boot Actuator:
Definition: Provides production-ready features to help monitor and manage applications.
Example: Endpoints for health checks, metrics, and environment info.

5.Spring Boot DevTools:
Definition: Provides additional development-time features to aid in development.
Example: Automatic restart, live reload, and configurations for development environment.

6.Embedded Servers:
Definition: Embedded web servers like Tomcat, Jetty, or Undertow that allow running Spring Boot applications as standalone applications.
Example: Run applications without needing a separate application server.

7.Spring Initializr:
Definition: A web-based tool to bootstrap a new Spring Boot project with dependencies and configurations.
Example: https://start.spring.io/ to generate a new project.

Summary
Starters: Simplify dependency management.
Auto-Configuration: Reduces boilerplate configuration.
CLI: Quick development with Groovy.
Actuator: Adds monitoring and management endpoints.
DevTools: Enhances development productivity.
Embedded Servers: Run applications standalone.
Initializr: Quick project setup.


Key Features of Spring Boot
1.Auto-Configuration:
Automatically configures your application based on the dependencies on the classpath.

2.Spring Boot Starters:
Pre-configured dependency descriptors for various use cases to simplify Maven/Gradle configuration.

3.Embedded Servers:
Includes embedded web servers (Tomcat, Jetty, Undertow) so you can run applications as standalone JARs.

4.Spring Boot CLI:
Command-line interface for rapid development and testing using Groovy scripts.

5.Spring Boot Actuator:
Adds production-ready features like monitoring, metrics, and health checks.

6.Spring Initializr:
Web-based tool to quickly bootstrap a new Spring Boot project with dependencies and configurations.

7.Spring Boot DevTools:
Provides additional development-time features such as automatic restarts, live reload, and configurations for the development environment.

8.Externalized Configuration:
Allows configuring application behavior via properties or YAML files.

9.Security:
Integrates easily with Spring Security for securing applications.

10.Microservices Support:
Facilitates building and deploying microservices with features like embedded servers and easy integration with cloud platforms.



HOW SPRING BOOT WORKS INTERNALLY:
Spring Boot simplifies the development of Spring-based applications by providing a set of conventions and default configurations. 

Starter Dependencies: Spring Boot offers starter dependencies (e.g., spring-boot-starter-web) to include a curated set of dependencies for a specific functionality, reducing the need for manual dependency management.

Auto-Configuration: At runtime, Spring Boot's auto-configuration mechanism uses @EnableAutoConfiguration to automatically configure beans and settings based on the classpath and defined beans in the context.
                    This is achieved through a series of conditional configurations specified in META-INF/spring.factories.

Embedded Servers: For web applications, Spring Boot provides embedded servers (e.g., Tomcat, Jetty) that can run the application directly without needing external server deployment. 
                  This is configured through the spring-boot-starter-web dependency.

SpringApplication: The SpringApplication class is the entry point for launching a Spring Boot application. It sets up the default configuration, starts the Spring context, performs classpath scans,
                    and launches the embedded server if needed.

Application Context: Spring Boot initializes the Spring Application Context, which is a central interface to the Spring framework's Inversion of Control (IoC) container. 
                     It manages beans and their dependencies, lifecycle, and configuration.

Configuration Properties: Spring Boot simplifies external configuration through properties files (application.properties or application.yml). The @Value and @ConfigurationProperties annotations are used 
                          to inject configuration properties into beans.

Profiles: Spring Boot supports profiles to allow different configurations for different environments (e.g., development, testing, production). Profiles can be activated via properties or environment variables, 
          enabling context-specific beans and configurations.

Actuator: Spring Boot Actuator provides production-ready features like monitoring and managing applications through various endpoints (e.g., health checks, metrics).

Spring Initializer: Spring Boot applications are often created using Spring Initializr,which provides a web-based interface to generate a Spring Boot project structure with necessary dependencies & configurations.

Convention Over Configuration: Spring Boot follows principle of convention over configuration, providing sensible defaults to reduce the need for explicit configuration while allowing customization when necessary.

MAJOR STARTER DEPENDENCIES:
Spring Boot provides a range of starter dependencies to simplify the setup of common frameworks and functionalities.

spring-boot-starter-web: Includes dependencies for building web applications, both RESTful and traditional MVC. It includes Spring MVC, Tomcat (as the default embedded container), Jackson for JSON processing, 
                        and validation support.

spring-boot-starter-data-jpa: Provides support for the Java Persistence API (JPA) using Spring Data JPA with Hibernate as the default ORM provider. It includes dependencies for database interaction,
                              ORM, and transaction management.

spring-boot-starter-security: Adds Spring Security for authentication and authorization. It includes common security practices, configurations, and filters to secure web applications.

spring-boot-starter-thymeleaf: Integrates the Thymeleaf templating engine, making it easy to build server-side rendered HTML views with Spring MVC.

spring-boot-starter-test: Includes testing libraries and frameworks like JUnit, Spring Test, AssertJ, Hamcrest, Mockito, and JSONassert, providing comprehensive support for writing unit and integration tests.

spring-boot-starter-actuator: Provides production-ready features for monitoring and managing applications, including endpoints for health checks, metrics, and environment information.

spring-boot-starter-logging: Configures logging with Logback as the default logger, including SLF4J for logging abstraction.

spring-boot-starter-data-mongodb: Adds support for MongoDB, including Spring Data MongoDB to simplify database operations with MongoDB.

spring-boot-starter-validation: Provides support for bean validation using Hibernate Validator as the default implementation of the Bean Validation (JSR-380) API.

spring-boot-starter-aop: Adds support for Aspect-Oriented Programming (AOP) with Spring AOP and AspectJ.

spring-boot-starter-batch: Simplifies the setup of Spring Batch for processing large volumes of data, including reading, processing, and writing data.

spring-boot-starter-mail: Adds support for sending emails using the JavaMailSender interface, including dependencies for JavaMail and Spring’s email utilities.


HOW TO CONFIGURE SPRING BOOT EXTERNALLY:

 1)application.properties or application.yml
   Place a file named application.properties or application.yml in the src/main/resources directory.
   Define key-value pairs or YAML structure for configuration settings (server port and data source URL)

2)Environment Variables
  Set environment variables to override Spring Boot properties.(export SPRING_DATASOURCE_URL=jdbc:mysql://localhost:3306/mydb)

3)Application Profiles(spring.profiles.active=dev)
  Use profiles to manage different configurations for different environments.
  Define profile-specific properties files (e.g., application-dev.properties, application-prod.properties).
  Activate a profile using environment variables, command-line arguments, or within the properties file.

4)Spring Cloud Config(spring.cloud.config.uri=http://config-server:8888)
  Use Spring Cloud Config to externalize configuration to a centralized server.
  Store configurations in a remote Git repository or other supported storage.
  Configure your application to fetch configurations from the Spring Cloud Config Server


5). ConfigurationProperties
   Use @ConfigurationProperties to bind external properties to a Java bean

   @ConfigurationProperties(prefix = "app")
   public class AppConfig {
    private String name;
    private String description;
    // getters and setters
}

External configuration in Spring Boot is achieved through properties or YAML files, environment variables, command-line arguments, application profiles, and Spring Cloud Config, providing flexibility
and separation of concerns for different deployment environments.

INVERSION OF CONTROL:
Inversion of Control (IoC) is a design principle in which the control of object creation and dependency management is transferred from the application code to a container or framework. In Spring, 
the IoC container is responsible for instantiating, configuring, and managing the lifecycle of beans (objects).

Types of IoC Containers in Spring:
1.BeanFactory:

Description: The simplest container that provides basic IoC functionality.
Features: Lazy initialization (beans are created when needed).
          
2.ApplicationContext:

Description: Extends BeanFactory and adds more enterprise-specific functionality.
Features: Eager initialization (beans are created at startup), support for event propagation, internationalization, and more.
          Common Implementations:
ClassPathXmlApplicationContext: Loads context from an XML file located in the classpath.
FileSystemXmlApplicationContext: Loads context from an XML file in the file system.
AnnotationConfigApplicationContext: Loads context from Java-based configuration using annotations.

Summary:
The IoC container in Spring manages the creation, configuration, and lifecycle of beans. The main types are BeanFactory for basic needs and ApplicationContext for advanced features,
facilitating flexible and decoupled application development.

@Configuration
public class AppConfig {
    @Bean
    public MyService myService() {
        return new MyService();
    }
}

public class MyService {
    public void doSomething() {
        System.out.println("Doing something...");
    }
}

public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        MyService myService = context.getBean(MyService.class);
        myService.doSomething();
    }
}

DEPENDENCY INJECTION:
Dependency Injection (DI) is a design pattern used in software development to achieve Inversion of Control (IoC) between classes and their dependencies. It allows objects to receive their dependencies 
from an external source rather than creating them internally, promoting loose coupling and easier testing.

1.Constructor Injection: Dependencies are provided through a class constructor.

public class MyService {
    private final MyRepository repository;

    public MyService(MyRepository repository) {
        this.repository = repository;
    }
}

2.Setter Injection: Dependencies are provided through setter methods

public class MyService {
    private MyRepository repository;

    public void setRepository(MyRepository repository) {
        this.repository = repository;
    }
}
3.Field Injection: Dependencies are provided directly into fields (typically using annotations like @Autowired in Spring).

public class MyService {
    @Autowired
    private MyRepository repository;
}

Summary
Dependency Injection inverts the control of managing dependencies from the class itself to an external container or framework, enhancing modularity and testability.
   
APPLICATION.PROPERTIES FILE IN SPRING BOOT:

The application.properties file in Spring Boot is used to configure application settings and externalize configuration. This file allows developers to set various properties for the application, 
including server settings, database connections, logging configurations, and more.

Key Features
Configuration: Define various application-level settings.
Externalization: Keep configurations outside the codebase for different environments (development, testing, production).

1.Server Configuration:
server.port=8081

2.Database Configuration:
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=password

3.Logging Configuration:
logging.level.org.springframework=DEBUG

4.Profile-Specific Properties: Use application-{profile}.properties for environment-specific configurations.
spring.profiles.active=dev

Summary
The application.properties file is a central place to define application configurations in Spring Boot, enabling easy management and customization of settings without changing the codebase.


FLOW OF SPRING BOOT APPLICATION:
1.Initialization:The application starts with the main method, which invokes SpringApplication.run().
  @SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}
2.Auto-Configuration:

  Spring Boot’s auto-configuration mechanism scans the classpath and applies default configurations based on the dependencies found.
  This is enabled by the @SpringBootApplication annotation, which combines @EnableAutoConfiguration, @ComponentScan, and @Configuration.

3.Application Context Setup:
  An ApplicationContext (usually a WebApplicationContext for web apps) is created.
  Spring beans are instantiated, configured, and wired together based on the configurations provided.

4.Embedded Server Startup:

  For web applications, an embedded server (e.g., Tomcat, Jetty) is started automatically.
  The server listens for incoming HTTP requests.

5.Controller Mapping:

  @RestController or @Controller classes define endpoints using @RequestMapping, @GetMapping, etc.
  Requests are mapped to the appropriate controller methods.

6.Request Handling:

  Incoming requests are handled by DispatcherServlet, which delegates them to the appropriate controllers.
  Controllers process the request, interact with service and repository layers as needed, and return a response.

7.Response:

  The response is returned to the client (e.g., JSON response in a RESTful application).
  View templates (e.g., Thymeleaf) may be rendered for web applications.

8.Lifecycle Management:

  The application context manages the lifecycle of beans, handling initialization and destruction.
  Beans can be annotated with @PostConstruct and @PreDestroy for custom initialization and cleanup.

Summary
The flow of a Spring Boot application involves starting with SpringApplication.run(), applying auto-configuration, setting up the application context, starting an embedded server,
handling requests via controllers, and managing the lifecycle of beans. This flow leverages Spring’s powerful dependency injection and IoC capabilities to streamline application development.

HIBERNATE VS JPA:
Hibernate vs JPA: A Concise Comparison
JPA (Java Persistence API)
  Specification: JPA is a specification for object-relational mapping (ORM) in Java, providing a set of interfaces and abstract methods for ORM.
  Standardization: It standardizes the way Java objects are mapped to database tables and how queries are constructed.
  Vendor-Neutral: JPA does not provide implementation; it requires an ORM tool for implementation (like Hibernate).
Hibernate:
  Implementation: Hibernate is a popular ORM framework that implements the JPA specification.
  Additional Features: Beyond JPA, Hibernate offers additional features like caching, lazy loading, and a more powerful query language (HQL).
  Direct Use: Hibernate can be used directly without JPA, utilizing its own API

Key Points
JPA:
  Standard API for ORM.
  Vendor-neutral.
  Requires an implementation (e.g., Hibernate, EclipseLink).
Hibernate:
  Full-fledged ORM framework.
  Implements JPA.
  Provides additional features not covered by JPA.

JPA (Abstract):
  @Entity
  public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    // getters and setters
}

Hibernate (Implementation):
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
User user = new User();
user.setName("John");
session.save(user);
tx.commit();
session.close();

Summary
JPA is a specification that defines the standard for ORM in Java, while Hibernate is an ORM framework that implements JPA and provides additional features. JPA provides a unified approach to ORM, 
and Hibernate enhances it with more robust capabilities.

SESSION VS SESSION FACTORY:

SessionFactory:
Definition: A heavyweight object that provides a thread-safe way to create Session instances.
Lifecycle: Created once per application (typically during startup) and kept for the entire lifecycle of the application.
Configuration: Configured using Hibernate configuration files or programmatically.
Purpose: Manages and configures database connections, provides Session instances, and serves as a factory for Session objects.

Session:
Definition: A lightweight, non-thread-safe object that represents a single unit of work with the database.
Lifecycle: Short-lived; created and closed per request or transaction.
Usage: Used to perform CRUD operations (Create, Read, Update, Delete) on persistent objects.
Transaction Management: Each Session instance is associated with a database transaction.

Key Points

SessionFactory:
Scope: Application-wide, one instance for the entire application.
Responsibility: Configuring Hibernate and providing Session objects.
Performance: Heavyweight, costly to create, should be created once and reused.

Session:
Scope: Per transaction or request, multiple instances can exist simultaneously.
Responsibility: Managing the persistence operations for a single unit of work.
Performance: Lightweight, designed to be created and closed frequently.


SessionFactory:
SessionFactory sessionFactory = new Configuration().configure().buildSessionFactory();

Session:
Session session = sessionFactory.openSession();
Transaction tx = session.beginTransaction();
// Perform database operations
tx.commit();
session.close();


Summary
SessionFactory: A heavyweight, thread-safe object created once per application to manage database connections and provide Session objects.
Session: A lightweight, non-thread-safe object created per transaction or request to perform CRUD operations and manage a single unit of work with the database.


PROFILE IN SPRING:
In Spring, a profile is a way to segregate parts of your application configuration and make it available only in certain environments. Profiles are typically used to define different configurations 
for different environments like development, testing, and production.

Key Points about Profiles in Spring
Definition: Profiles allow you to group beans and configuration settings so that they are only activated in a specific environment.
Activation: Profiles can be activated using environment variables, command-line arguments, or configuration files.

How to Use Profiles:
1. Annotate Beans:
   Use @Profile to specify the profile(s) in which a bean should be active.

@Configuration
@Profile("dev")
public class DevConfig {
    // Beans and configuration for development
}

@Configuration
@Profile("prod")
public class ProdConfig {
    // Beans and configuration for production
}


2.Activate Profiles:
  In application.properties or application.yml
    spring.profiles.active=dev
  Using command-line arguments:
    java -jar myapp.jar --spring.profiles.active=dev

3.Conditional Beans:
  Use @Profile directly on beans to load them conditionally.

@Bean
@Profile("dev")
public DataSource devDataSource() {
    // DataSource configuration for development
}

@Bean
@Profile("prod")
public DataSource prodDataSource() {
    // DataSource configuration for production
}


Summary
Profiles in Spring allow you to manage different configurations and beans for different environments, enhancing flexibility and simplifying environment-specific settings.
They can be activated through properties files, environment variables, or command-line arguments.

SPRING MVC DESIGN PATTERN:
Spring MVC (Model-View-Controller) is a framework within the Spring ecosystem that follows the MVC design pattern to separate concerns in web applications. It helps organize the code by dividing 
it into three main components: Model, View, and Controller.

Components of Spring MVC:
1.Model:

  Definition: Represents the application's data and business logic.
  Purpose: Encapsulates the data to be displayed and the state of the application.
  Example: POJOs (Plain Old Java Objects) that are used to hold data

public class User {
    private String name;
    private String email;
    // Getters and Setters
}


2.View:

  Definition: Represents the presentation layer, usually HTML or JSP pages.
  Purpose: Displays the data provided by the Model.
  Example: JSP, Thymeleaf, FreeMarker templates.
<!-- Example Thymeleaf Template -->
<html>
<body>
    <h1>Hello, <span th:text="${user.name}">User</span>!</h1>
</body>
</html>

3.Controller:

  Definition: Manages the flow of the application, handling user input and interactions.
  Purpose: Processes incoming requests, interacts with the Model, and returns the appropriate View.
  Example: Spring controllers annotated with @Controller or @RestController.

@Controller
public class UserController {
    @GetMapping("/user")
    public String getUser(Model model) {
        User user = new User();
        user.setName("John");
        user.setEmail("john@example.com");
        model.addAttribute("user", user);
        return "userView";
    }
}

Request Handling Flow:
  Client Request: A client sends a request to the server.
  DispatcherServlet: The central servlet (configured in web.xml or automatically in Spring Boot) that dispatches requests to appropriate controllers.
  Controller: The controller processes the request, interacts with the model, and determines the view to render.
  Model: Data is prepared and added to the model.
  View: The view renders the response using the data from the model.
  Response: The view is sent back to the client as an HTTP response.

summary:
Spring MVC implements the Model-View-Controller pattern to separate concerns in web applications, enhancing modularity and maintainability. The Model represents the data, 
the View displays the data, and the Controller handles user requests and interactions, coordinating between the Model and the View

SPRING VS SPRING BOOT:
Spring Framework:
 Overview: A comprehensive and flexible framework for building enterprise Java applications.
 Configuration: Requires extensive XML configuration or Java-based configuration (using annotations).
 Components: Provides a wide range of modules (e.g., Spring Core, Spring AOP, Spring MVC, Spring Security) for different functionalities.
 Complexity: Setup and configuration can be complex and time-consuming.
Spring Boot:
 Overview: An extension of the Spring Framework designed to simplify the development of stand-alone, production-ready Spring applications.
 Configuration: Uses convention over configuration, providing default settings and reducing boilerplate code. Configuration is typically done via properties files and annotations.
 Components: Bundles dependencies and configurations for various modules, including embedded servers (e.g., Tomcat, Jetty).
 Simplicity: Streamlines the setup process with auto-configuration, starter dependencies, and embedded servers.

Key Differences
Setup and Configuration:
 Spring: Requires manual setup and configuration.
 Spring Boot: Provides auto-configuration and starter dependencies to simplify setup.

Dependency Management:
 Spring: Requires manual management of dependencies.
 Spring Boot: Uses starter dependencies to automatically include relevant libraries.

Embedded Server:
 Spring: Requires external server configuration.
 Spring Boot: Includes embedded servers for easy deployment.

Project Initialization:
 Spring: Requires detailed configuration.
 Spring Boot: Provides the Spring Initializr (a web-based tool) for generating project templates.

Microservices:
 Spring: Can be used for building microservices but needs additional setup.
 Spring Boot: Optimized for building microservices with minimal setup.

Spring:
@Configuration
public class AppConfig {
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}

@Component
public class MyComponent {
    @Autowired
    private MyService myService;
    // Use myService
}

Spring Boot:
@SpringBootApplication
public class MyApp {
    public static void main(String[] args) {
        SpringApplication.run(MyApp.class, args);
    }
}

@Service
public class MyService {
    // Business logic
}

@RestController
public class MyController {
    @Autowired
    private MyService myService;
    
    @GetMapping("/hello")
    public String hello() {
        return "Hello, World!";
    }
}

Summary
Spring Framework: A robust, flexible framework that requires manual configuration, suitable for complex applications.
Spring Boot: A streamlined extension of Spring that simplifies development with auto-configuration, starter dependencies, and embedded servers, ideal for quick development and microservices.


HIBERNATE QUERY LANGUAGE:

HQL (Hibernate Query Language) is an object-oriented query language similar to SQL, but it operates on the persistent objects (entities) rather than directly on database tables.

Key Features
 Object-Oriented: HQL queries are based on the entity objects and their properties rather than the database tables and columns.
 Database-Independent: HQL abstracts the SQL specifics of the underlying database, making the application more portable.
 Powerful: Supports operations like joins, group by, and aggregate functions, similar to SQL.

Basic Syntax:
 Select Queries:
   String hql = "FROM User";
   Query query = session.createQuery(hql);
   List results = query.list();
 Where Clause:
    String hql = "FROM User U WHERE U.id = :userId";
    Query query = session.createQuery(hql);
    query.setParameter("userId", 1);
    List results = query.list();
 Joins:
    String hql = "SELECT U FROM User U JOIN U.orders O WHERE O.amount > :amount";
    Query query = session.createQuery(hql);
    query.setParameter("amount", 1000);
    List results = query.list();
Aggregations:
    String hql = "SELECT COUNT(U) FROM User U";
    Query query = session.createQuery(hql);
    Long count = (Long) query.uniqueResult();

Usage example:
  Session session = sessionFactory.openSession();
  Transaction tx = session.beginTransaction();
  String hql = "FROM User U WHERE U.name = :userName";
  Query query = session.createQuery(hql);
  query.setParameter("userName", "John");
  List<User> users = query.list();
  tx.commit();
  session.close();

Summary:
  HQL is a powerful, database-independent query language used in Hibernate to perform CRUD operations on persistent objects. It provides an object-oriented approach to query databases, 
  making it easier to work with Java entities and ensuring portability across different database systems.


OAuth: 
   OAuth (Open Authorization) is an open standard protocol that allows secure authorization and resource access between applications without exposing user credentials.

Key Concepts
  Resource Owner: The user who owns the data.
  Client: The application requesting access to the user's data.
  Authorization Server: The server that authenticates the resource owner and issues access tokens.
  Resource Server: The server hosting the user's protected resources, accepts and validates access tokens.
Flow Overview:
 1.Authorization Request: The client requests authorization from the resource owner (user).
 2.Authorization Grant: The resource owner grants authorization (e.g., via a consent screen).
 3.Access Token Request: The client requests an access token from the authorization server, providing the authorization grant.
 4.Access Token: The authorization server issues an access token to the client.
 5.Resource Request: The client uses the access token to request resources from the resource server.
 6.Protected Resource: The resource server validates the access token and serves the requested resource.
Example:
 1.User Login: User logs in to a third-party app using their Google account.
 2.Consent: User consents to allow the app to access their Google profile.
 3.Token Exchange: The app receives an access token from Google's authorization server.
 4.Resource Access: The app uses the access token to fetch the user's Google profile data.

Summary
OAuth enables third-party applications to access user resources without sharing passwords, using a secure, token-based authorization process.


Storing Passwords in Spring Boot:
  In Spring Boot, passwords are securely stored by hashing them using a password encoder. The most commonly used approach involves BCrypt, a hashing algorithm designed for storing passwords.
Key Steps
 1.Include Dependency: Ensure the spring-boot-starter-security dependency is included in your pom.xml or build.gradle.
    <dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>

2.Password Encoder Configuration: Define a BCryptPasswordEncoder bean in your configuration class
  @Configuration
public class SecurityConfig {
    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
3.Hashing Passwords: Use the password encoder to hash passwords before storing them in the database.
  @Autowired
private BCryptPasswordEncoder passwordEncoder;

public void registerUser(User user) {
    String encodedPassword = passwordEncoder.encode(user.getPassword());
    user.setPassword(encodedPassword);
    userRepository.save(user);
}
4.Verifying Passwords: Use the password encoder to verify passwords during authentication.

public boolean authenticate(String rawPassword, String encodedPassword) {
    return passwordEncoder.matches(rawPassword, encodedPassword);
}

Summary
In Spring Boot, passwords are securely stored by hashing them with a password encoder such as BCryptPasswordEncoder. This involves hashing the password before saving it to the database and
verifying the hashed password during authentication.


















   




   




























