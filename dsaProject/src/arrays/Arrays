Check if Array is Sorted
boolean sorted = IntStream.range(0, arr.length - 1).allMatch(i -> arr[i] <= arr[i + 1]);

Find Union of Two Arrays
Set<Integer> set = new HashSet<>();
set.addAll(Arrays.asList(arr1));
set.addAll(Arrays.asList(arr2));
Integer[] union = set.toArray(new Integer[0]);

Find Intersection of Two Arrays
Set<Integer> set = new HashSet<>(Arrays.asList(arr1));
set.retainAll(Arrays.asList(arr2));
Integer[] intersection = set.toArray(new Integer[0]);

Merge Two Arrays
int[] merged = new int[arr1.length + arr2.length];
System.arraycopy(arr1, 0, merged, 0, arr1.length);
System.arraycopy(arr2, 0, merged, arr1.length, arr2.length);

Binary Search
int index = Arrays.binarySearch(arr, key);

Rotate Array by K Positions
Collections.rotate(Arrays.asList(arr), k);

Arrays
General Strategies
Use Multiple Pointers:
Useful for problems involving sorting or subarray/window calculations.
Example: left and right pointers for finding pairs with a given sum.

Sliding Window:
Ideal for problems involving contiguous subarrays or sequences.
Example: Maximum sum subarray of size k.

Frequency Count:
Useful for problems involving duplicates or element frequency.
Example: Finding the majority element.

Sort When Possible:
Sorting can simplify logic for finding pairs, triplets, or managing ranges.
Example: Two Sum problem with sorted array.

Binary Search:
Use for searching or finding elements in a sorted array.
Example: Finding the insertion position.

Optimization Techniques
Space Optimization:
Avoid using extra space if the problem can be solved in place.
Example: Removing duplicates from a sorted array.

Time Complexity Awareness:
Aim for O(n) or O(n log n) solutions where possible.
Example: Use hash maps for counting instead of nested loops.

Edge Cases Handling:
Always consider empty arrays, single elements, maximum/minimum values.
Example: Handling arrays of length 0 or 1.




