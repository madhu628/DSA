Convert String to Integer
int number = Integer.parseInt(str);

int number = 0;
for (int i = 0; i < str.length(); i++) {
    number = number * 10 + (str.charAt(i) - '0');
}

Convert Integer to String
String strNumber = Integer.toString(num);

StringBuilder sb = new StringBuilder();
int num = number;
boolean isNegative = num < 0;
if (isNegative) num = -num;
do {
    sb.append((char) ('0' + (num % 10)));
    num /= 10;
} while (num > 0);
if (isNegative) sb.append('-');
String strNumber = sb.reverse().toString();

Check if String Contains Only Digits
boolean isDigit = str.chars().allMatch(Character::isDigit);

boolean isDigit = true;
for (int i = 0; i < str.length(); i++) {
    if (!Character.isDigit(str.charAt(i))) {
        isDigit = false;
        break;
    }
}

Replace Substring
String replaced = str.replace("old", "new");

StringBuilder sb = new StringBuilder();
String target = "old";
String replacement = "new";
for (int i = 0; i < str.length();) {
    if (str.startsWith(target, i)) {
        sb.append(replacement);
        i += target.length();
    } else {
        sb.append(str.charAt(i));
        i++;
    }
}
String replaced = sb.toString();

Split String by Delimiter
String[] parts = str.split(",");

List<String> parts = new ArrayList<>();
StringBuilder sb = new StringBuilder();
for (int i = 0; i < str.length(); i++) {
    if (str.charAt(i) == ',') {
        parts.add(sb.toString());
        sb.setLength(0);
    } else {
        sb.append(str.charAt(i));
    }
}
parts.add(sb.toString());

Join Strings
String joined = String.join(",", listOfStrings);

StringBuilder sb = new StringBuilder();
for (int i = 0; i < list.size(); i++) {
    sb.append(list.get(i));
    if (i < list.size() - 1) {
        sb.append(",");
    }
}
String joined = sb.toString();


String Formatting
String formatted = String.format("Hello, %s!", name);

String formatted = "Hello, " + name + "!";

Lambda Expressions: Use lambda expressions and streams for concise array and string manipulations.
Regular Expressions: Use String.replaceAll for complex string replacements.
Collections: Use collections like HashSet, ArrayList, or LinkedList for efficient data operations and transformations.
Utility Methods: Utilize utility methods from Arrays, Collections, and String classes for common tasks.
Character Operations: Use Character methods for character-level checks and transformations.
Handling Nulls: Always check for nulls in input to avoid NullPointerException.

Manual Loops: Use manual loops (for, while, do-while) for operations typically handled by built-in methods.
Basic Operations: Implement basic operations such as indexOf, substring, replace, split, etc., using loops and conditionals.
Character Checks: Use simple if-else conditions for character checks and manipulations.
Avoid Collections: Stick to arrays and manual array manipulations instead of using collections like ArrayList, HashSet, etc.
Buffer Usage: Use StringBuilder for efficient string manipulations, especially in a loop.

Strings
General Strategies
Two Pointers:
Effective for problems involving substring search, palindromes, etc.
Example: Finding the longest palindromic substring.

Character Count/Frequency:
Useful for anagram checks or character frequency problems.
Example: Checking if two strings are anagrams.

Sliding Window:
Ideal for problems involving substrings or contiguous sequences.
Example: Finding the smallest substring containing all characters of another string.

In-place Modifications:
Modify the string using StringBuilder to handle mutable changes efficiently.
Example: Removing specific characters from a string.

Optimization Techniques
Use Hash Maps:
For frequency counts or character mappings.
Example: Longest substring without repeating characters.

StringBuilder for Concatenation:
Avoid using + for concatenation inside loops.
Example: Building a result string from parts.

Regular Expressions:
Use cautiously for pattern matching but be mindful of performance.
Example: Matching or replacing patterns in a string.

Avoid Redundant Work:
Break early from loops when conditions are met to save time.
Example: Early exit in substring search.




